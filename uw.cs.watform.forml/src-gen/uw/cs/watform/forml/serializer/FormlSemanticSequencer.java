/*
 * generated by Xtext
 */
package uw.cs.watform.forml.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uw.cs.watform.forml.forml.Aggregation;
import uw.cs.watform.forml.forml.AndNode;
import uw.cs.watform.forml.forml.Assign;
import uw.cs.watform.forml.forml.AssignList;
import uw.cs.watform.forml.forml.Association;
import uw.cs.watform.forml.forml.Attribute;
import uw.cs.watform.forml.forml.BehaviourModel;
import uw.cs.watform.forml.forml.BoolType;
import uw.cs.watform.forml.forml.Cardinality;
import uw.cs.watform.forml.forml.CompDecl;
import uw.cs.watform.forml.forml.Composition;
import uw.cs.watform.forml.forml.Constraint;
import uw.cs.watform.forml.forml.Decl;
import uw.cs.watform.forml.forml.Entity;
import uw.cs.watform.forml.forml.EnumConst;
import uw.cs.watform.forml.forml.Enumeration;
import uw.cs.watform.forml.forml.Feature;
import uw.cs.watform.forml.forml.FeatureModule;
import uw.cs.watform.forml.forml.FeatureNode;
import uw.cs.watform.forml.forml.FormlPackage;
import uw.cs.watform.forml.forml.Fragment;
import uw.cs.watform.forml.forml.FragmentType;
import uw.cs.watform.forml.forml.Function;
import uw.cs.watform.forml.forml.Guard;
import uw.cs.watform.forml.forml.InitState;
import uw.cs.watform.forml.forml.Input;
import uw.cs.watform.forml.forml.InputList;
import uw.cs.watform.forml.forml.IntType;
import uw.cs.watform.forml.forml.Macro;
import uw.cs.watform.forml.forml.Multiplicity;
import uw.cs.watform.forml.forml.OrNode;
import uw.cs.watform.forml.forml.Output;
import uw.cs.watform.forml.forml.OutputList;
import uw.cs.watform.forml.forml.Predicate;
import uw.cs.watform.forml.forml.Priority;
import uw.cs.watform.forml.forml.RefMessage;
import uw.cs.watform.forml.forml.ReferenceType;
import uw.cs.watform.forml.forml.Region;
import uw.cs.watform.forml.forml.RegionContext;
import uw.cs.watform.forml.forml.Role;
import uw.cs.watform.forml.forml.SPL;
import uw.cs.watform.forml.forml.State;
import uw.cs.watform.forml.forml.StateContext;
import uw.cs.watform.forml.forml.StateMachine;
import uw.cs.watform.forml.forml.StateMachineContext;
import uw.cs.watform.forml.forml.StringType;
import uw.cs.watform.forml.forml.TranFragment;
import uw.cs.watform.forml.forml.TransList;
import uw.cs.watform.forml.forml.Transition;
import uw.cs.watform.forml.forml.Trigger;
import uw.cs.watform.forml.forml.UndefinedType;
import uw.cs.watform.forml.forml.Variable;
import uw.cs.watform.forml.forml.WCA;
import uw.cs.watform.forml.forml.WCAFragment;
import uw.cs.watform.forml.forml.WCAFragmentList;
import uw.cs.watform.forml.forml.WCAList;
import uw.cs.watform.forml.forml.WCE;
import uw.cs.watform.forml.forml.WorldModel;
import uw.cs.watform.forml.forml.XORNode;
import uw.cs.watform.forml.forml.andPred;
import uw.cs.watform.forml.forml.atomic;
import uw.cs.watform.forml.forml.basePred;
import uw.cs.watform.forml.forml.boolExpr;
import uw.cs.watform.forml.forml.impPred;
import uw.cs.watform.forml.forml.intBase;
import uw.cs.watform.forml.forml.intExpr;
import uw.cs.watform.forml.forml.multExpr;
import uw.cs.watform.forml.forml.notPred;
import uw.cs.watform.forml.forml.orPred;
import uw.cs.watform.forml.forml.predExpr;
import uw.cs.watform.forml.forml.predExpr2;
import uw.cs.watform.forml.forml.predExpr3;
import uw.cs.watform.forml.forml.setExpr;
import uw.cs.watform.forml.forml.setExpr2;
import uw.cs.watform.forml.forml.setExpr3;
import uw.cs.watform.forml.forml.setExprBase;
import uw.cs.watform.forml.forml.unspecified;
import uw.cs.watform.forml.services.FormlGrammarAccess;

@SuppressWarnings("all")
public class FormlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FormlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FormlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FormlPackage.ACTION:
				sequence_Action(context, (uw.cs.watform.forml.forml.Action) semanticObject); 
				return; 
			case FormlPackage.AGGREGATION:
				sequence_Aggregation(context, (Aggregation) semanticObject); 
				return; 
			case FormlPackage.AND_NODE:
				sequence_AndNode(context, (AndNode) semanticObject); 
				return; 
			case FormlPackage.ASSIGN:
				sequence_Assign(context, (Assign) semanticObject); 
				return; 
			case FormlPackage.ASSIGN_LIST:
				sequence_AssignList(context, (AssignList) semanticObject); 
				return; 
			case FormlPackage.ASSOCIATION:
				sequence_Association(context, (Association) semanticObject); 
				return; 
			case FormlPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case FormlPackage.BEHAVIOUR_MODEL:
				sequence_BehaviourModel(context, (BehaviourModel) semanticObject); 
				return; 
			case FormlPackage.BOOL_TYPE:
				sequence_BoolType(context, (BoolType) semanticObject); 
				return; 
			case FormlPackage.CARDINALITY:
				sequence_Cardinality(context, (Cardinality) semanticObject); 
				return; 
			case FormlPackage.COMP_DECL:
				sequence_CompDecl(context, (CompDecl) semanticObject); 
				return; 
			case FormlPackage.COMPOSITION:
				sequence_Composition(context, (Composition) semanticObject); 
				return; 
			case FormlPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case FormlPackage.DECL:
				sequence_Decl(context, (Decl) semanticObject); 
				return; 
			case FormlPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case FormlPackage.ENUM_CONST:
				sequence_EnumConst(context, (EnumConst) semanticObject); 
				return; 
			case FormlPackage.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case FormlPackage.FEATURE:
				sequence_Feature(context, (Feature) semanticObject); 
				return; 
			case FormlPackage.FEATURE_MODULE:
				sequence_FeatureModule(context, (FeatureModule) semanticObject); 
				return; 
			case FormlPackage.FEATURE_NODE:
				sequence_FeatureNode(context, (FeatureNode) semanticObject); 
				return; 
			case FormlPackage.FRAGMENT:
				sequence_Fragment(context, (Fragment) semanticObject); 
				return; 
			case FormlPackage.FRAGMENT_TYPE:
				sequence_FragmentType(context, (FragmentType) semanticObject); 
				return; 
			case FormlPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case FormlPackage.GUARD:
				sequence_Guard(context, (Guard) semanticObject); 
				return; 
			case FormlPackage.INIT_STATE:
				sequence_InitState(context, (InitState) semanticObject); 
				return; 
			case FormlPackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case FormlPackage.INPUT_LIST:
				sequence_InputList(context, (InputList) semanticObject); 
				return; 
			case FormlPackage.INT_TYPE:
				sequence_IntType(context, (IntType) semanticObject); 
				return; 
			case FormlPackage.MACRO:
				sequence_Macro(context, (Macro) semanticObject); 
				return; 
			case FormlPackage.MULTIPLICITY:
				sequence_Multiplicity(context, (Multiplicity) semanticObject); 
				return; 
			case FormlPackage.OR_NODE:
				sequence_OrNode(context, (OrNode) semanticObject); 
				return; 
			case FormlPackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case FormlPackage.OUTPUT_LIST:
				sequence_OutputList(context, (OutputList) semanticObject); 
				return; 
			case FormlPackage.OVERRIDE:
				sequence_Override(context, (uw.cs.watform.forml.forml.Override) semanticObject); 
				return; 
			case FormlPackage.PREDICATE:
				sequence_Predicate(context, (Predicate) semanticObject); 
				return; 
			case FormlPackage.PRIORITY:
				sequence_Priority(context, (Priority) semanticObject); 
				return; 
			case FormlPackage.REF_MESSAGE:
				sequence_RefMessage(context, (RefMessage) semanticObject); 
				return; 
			case FormlPackage.REFERENCE_TYPE:
				sequence_ReferenceType(context, (ReferenceType) semanticObject); 
				return; 
			case FormlPackage.REGION:
				sequence_Region(context, (Region) semanticObject); 
				return; 
			case FormlPackage.REGION_CONTEXT:
				sequence_RegionContext(context, (RegionContext) semanticObject); 
				return; 
			case FormlPackage.ROLE:
				sequence_Role(context, (Role) semanticObject); 
				return; 
			case FormlPackage.SPL:
				sequence_SPL(context, (SPL) semanticObject); 
				return; 
			case FormlPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case FormlPackage.STATE_CONTEXT:
				sequence_StateContext(context, (StateContext) semanticObject); 
				return; 
			case FormlPackage.STATE_MACHINE:
				sequence_StateMachine(context, (StateMachine) semanticObject); 
				return; 
			case FormlPackage.STATE_MACHINE_CONTEXT:
				sequence_StateMachineContext(context, (StateMachineContext) semanticObject); 
				return; 
			case FormlPackage.STRING_TYPE:
				sequence_StringType(context, (StringType) semanticObject); 
				return; 
			case FormlPackage.SYSTEM:
				sequence_System(context, (uw.cs.watform.forml.forml.System) semanticObject); 
				return; 
			case FormlPackage.TRAN_FRAGMENT:
				sequence_TranFragment(context, (TranFragment) semanticObject); 
				return; 
			case FormlPackage.TRANS_LIST:
				sequence_TransList(context, (TransList) semanticObject); 
				return; 
			case FormlPackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			case FormlPackage.TRIGGER:
				sequence_Trigger(context, (Trigger) semanticObject); 
				return; 
			case FormlPackage.UNDEFINED_TYPE:
				sequence_UndefinedType(context, (UndefinedType) semanticObject); 
				return; 
			case FormlPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case FormlPackage.WCA:
				sequence_WCA(context, (WCA) semanticObject); 
				return; 
			case FormlPackage.WCA_FRAGMENT:
				sequence_WCAFragment(context, (WCAFragment) semanticObject); 
				return; 
			case FormlPackage.WCA_FRAGMENT_LIST:
				sequence_WCAFragmentList(context, (WCAFragmentList) semanticObject); 
				return; 
			case FormlPackage.WCA_LIST:
				sequence_WCAList(context, (WCAList) semanticObject); 
				return; 
			case FormlPackage.WCE:
				sequence_WCE(context, (WCE) semanticObject); 
				return; 
			case FormlPackage.WORLD_MODEL:
				sequence_WorldModel(context, (WorldModel) semanticObject); 
				return; 
			case FormlPackage.XOR_NODE:
				sequence_XORNode(context, (XORNode) semanticObject); 
				return; 
			case FormlPackage.AND_PRED:
				sequence_andPred(context, (andPred) semanticObject); 
				return; 
			case FormlPackage.ATOMIC:
				sequence_atomic(context, (atomic) semanticObject); 
				return; 
			case FormlPackage.BASE_PRED:
				sequence_basePred(context, (basePred) semanticObject); 
				return; 
			case FormlPackage.BOOL_EXPR:
				sequence_boolExpr(context, (boolExpr) semanticObject); 
				return; 
			case FormlPackage.IMP_PRED:
				sequence_impPred(context, (impPred) semanticObject); 
				return; 
			case FormlPackage.INT_BASE:
				sequence_intBase(context, (intBase) semanticObject); 
				return; 
			case FormlPackage.INT_EXPR:
				sequence_intExpr(context, (intExpr) semanticObject); 
				return; 
			case FormlPackage.MULT_EXPR:
				sequence_multExpr(context, (multExpr) semanticObject); 
				return; 
			case FormlPackage.NOT_PRED:
				sequence_notPred(context, (notPred) semanticObject); 
				return; 
			case FormlPackage.OR_PRED:
				sequence_orPred(context, (orPred) semanticObject); 
				return; 
			case FormlPackage.PRED_EXPR:
				sequence_predExpr(context, (predExpr) semanticObject); 
				return; 
			case FormlPackage.PRED_EXPR2:
				sequence_predExpr2(context, (predExpr2) semanticObject); 
				return; 
			case FormlPackage.PRED_EXPR3:
				sequence_predExpr3(context, (predExpr3) semanticObject); 
				return; 
			case FormlPackage.SET_EXPR:
				sequence_setExpr(context, (setExpr) semanticObject); 
				return; 
			case FormlPackage.SET_EXPR2:
				sequence_setExpr2(context, (setExpr2) semanticObject); 
				return; 
			case FormlPackage.SET_EXPR3:
				sequence_setExpr3(context, (setExpr3) semanticObject); 
				return; 
			case FormlPackage.SET_EXPR_BASE:
				sequence_setExprBase(context, (setExprBase) semanticObject); 
				return; 
			case FormlPackage.UNSPECIFIED:
				sequence_unspecified(context, (unspecified) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (
	 *         type=[ExprRef|QualifiedName] | 
	 *         (out=[Output|ID] list+=AssignList) | 
	 *         minexpr=setExpr | 
	 *         (lvalue=setExpr? rvalue=setExpr?) | 
	 *         (lvalue=intExpr rvalue=intExpr)
	 *     )?
	 */
	protected void sequence_Action(ISerializationContext context, uw.cs.watform.forml.forml.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprRef returns Aggregation
	 *     Concept returns Aggregation
	 *     Relationship returns Aggregation
	 *     Aggregation returns Aggregation
	 *
	 * Constraint:
	 *     (ctrl?='ctrl'? name=ID (whole=Decl | part=Decl)+)
	 */
	protected void sequence_Aggregation(ISerializationContext context, Aggregation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AndNode returns AndNode
	 *
	 * Constraint:
	 *     (featureNodes+=FeatureNode featureNodes+=FeatureNode+)
	 */
	protected void sequence_AndNode(ISerializationContext context, AndNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssignList returns AssignList
	 *
	 * Constraint:
	 *     (list+=Assign list+=Assign*)
	 */
	protected void sequence_AssignList(ISerializationContext context, AssignList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assign returns Assign
	 *
	 * Constraint:
	 *     (ref=[ExprRef|ID] (sexpr=setExpr | sexpr=intExpr))
	 */
	protected void sequence_Assign(ISerializationContext context, Assign semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprRef returns Association
	 *     Concept returns Association
	 *     Relationship returns Association
	 *     Association returns Association
	 *
	 * Constraint:
	 *     (ctrl?='ctrl'? name=ID (attributes+=Attribute | srcRole=Role | desRole=Role)*)
	 */
	protected void sequence_Association(ISerializationContext context, Association semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprRef returns Attribute
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (ctrl?='ctrl'? name=ID multiplicity=Multiplicity? type=AttributeType?)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BehaviourModel returns BehaviourModel
	 *
	 * Constraint:
	 *     featuremodules+=FeatureModule*
	 */
	protected void sequence_BehaviourModel(ISerializationContext context, BehaviourModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeType returns BoolType
	 *     BoolType returns BoolType
	 *
	 * Constraint:
	 *     {BoolType}
	 */
	protected void sequence_BoolType(ISerializationContext context, BoolType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cardinality returns Cardinality
	 *
	 * Constraint:
	 *     (lower=INT (upper=INT | many='*'))
	 */
	protected void sequence_Cardinality(ISerializationContext context, Cardinality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompDecl returns CompDecl
	 *
	 * Constraint:
	 *     (name=ID type=[Entity|ID])
	 */
	protected void sequence_CompDecl(ISerializationContext context, CompDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FormlPackage.Literals.DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FormlPackage.Literals.DECL__NAME));
			if (transientValues.isValueTransient(semanticObject, FormlPackage.Literals.DECL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FormlPackage.Literals.DECL__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompDeclAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCompDeclAccess().getTypeEntityIDTerminalRuleCall_3_0_1(), semanticObject.eGet(FormlPackage.Literals.DECL__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExprRef returns Composition
	 *     Concept returns Composition
	 *     Relationship returns Composition
	 *     Composition returns Composition
	 *
	 * Constraint:
	 *     (ctrl?='ctrl'? name=ID (whole=Decl | part=Decl)+)
	 */
	protected void sequence_Composition(ISerializationContext context, Composition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (predicates+=Predicate | macro+=Macro)*
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns Decl
	 *
	 * Constraint:
	 *     (name=ID multiplicity=Multiplicity? type=[Entity|ID])
	 */
	protected void sequence_Decl(ISerializationContext context, Decl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprRef returns Entity
	 *     Concept returns Entity
	 *     Roleable returns Entity
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (ctrl?='ctrl'? name=ID superType=[Entity|ID]? attributes+=Attribute* functions+=Function*)
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumConst returns EnumConst
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnumConst(ISerializationContext context, EnumConst semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FormlPackage.Literals.ENUM_CONST__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FormlPackage.Literals.ENUM_CONST__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumConstAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExprRef returns Enumeration
	 *     Concept returns Enumeration
	 *     Enumeration returns Enumeration
	 *
	 * Constraint:
	 *     (name=ID constant+=EnumConst constant+=EnumConst*)
	 */
	protected void sequence_Enumeration(ISerializationContext context, Enumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureModule returns FeatureModule
	 *
	 * Constraint:
	 *     (featureref=[Roleable|ID] (constraints=Constraint | statemachine+=StateMachine | fragments+=Fragment)*)
	 */
	protected void sequence_FeatureModule(ISerializationContext context, FeatureModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureNode returns FeatureNode
	 *
	 * Constraint:
	 *     (
	 *         feature=[Feature|ID] 
	 *         multiplicity=Multiplicity? 
	 *         featureNodes+=FeatureNode* 
	 *         xors+=XORNode* 
	 *         ands+=AndNode* 
	 *         ors+=OrNode*
	 *     )
	 */
	protected void sequence_FeatureNode(ISerializationContext context, FeatureNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprRef returns Feature
	 *     Concept returns Feature
	 *     Roleable returns Feature
	 *     Feature returns Feature
	 *
	 * Constraint:
	 *     (name=ID attributes+=Attribute* inputlist=InputList? outputlist=OutputList?)
	 */
	protected void sequence_Feature(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FragmentType returns FragmentType
	 *
	 * Constraint:
	 *     (state=StateContext | region=RegionContext | frag=TranFragment | statemachine=StateMachineContext | transitions+=Transition)+
	 */
	protected void sequence_FragmentType(ISerializationContext context, FragmentType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fragment returns Fragment
	 *
	 * Constraint:
	 *     (name=ID fragmentType+=FragmentType*)
	 */
	protected void sequence_Fragment(ISerializationContext context, Fragment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=ID type=AttributeType?)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Guard returns Guard
	 *
	 * Constraint:
	 *     predicate=Predicate?
	 */
	protected void sequence_Guard(ISerializationContext context, Guard semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitState returns InitState
	 *
	 * Constraint:
	 *     stateref=[State|ID]?
	 */
	protected void sequence_InitState(ISerializationContext context, InitState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputList returns InputList
	 *
	 * Constraint:
	 *     (inputs+=RefMessage inputs+=RefMessage*)?
	 */
	protected void sequence_InputList(ISerializationContext context, InputList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprRef returns Input
	 *     Concept returns Input
	 *     Message returns Input
	 *     Input returns Input
	 *
	 * Constraint:
	 *     (name=ID type=AttributeType? attributes+=Attribute* tos+=[Feature|ID]*)
	 */
	protected void sequence_Input(ISerializationContext context, Input semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeType returns IntType
	 *     IntType returns IntType
	 *
	 * Constraint:
	 *     {IntType}
	 */
	protected void sequence_IntType(ISerializationContext context, IntType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Macro returns Macro
	 *
	 * Constraint:
	 *     (name=ID (expr=setExpr | expr=intExpr))
	 */
	protected void sequence_Macro(ISerializationContext context, Macro semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiplicity returns Multiplicity
	 *
	 * Constraint:
	 *     (value=INT | many='*' | cardinality=Cardinality)
	 */
	protected void sequence_Multiplicity(ISerializationContext context, Multiplicity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrNode returns OrNode
	 *
	 * Constraint:
	 *     (featureNodes+=FeatureNode featureNodes+=FeatureNode+)
	 */
	protected void sequence_OrNode(ISerializationContext context, OrNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputList returns OutputList
	 *
	 * Constraint:
	 *     (outputs+=RefMessage outputs+=RefMessage*)?
	 */
	protected void sequence_OutputList(ISerializationContext context, OutputList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprRef returns Output
	 *     Concept returns Output
	 *     Message returns Output
	 *     Output returns Output
	 *
	 * Constraint:
	 *     (name=ID type=AttributeType? attributes+=Attribute* froms+=[Feature|ID]*)
	 */
	protected void sequence_Output(ISerializationContext context, Output semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Override returns Override
	 *
	 * Constraint:
	 *     transition=[Transition|ID]
	 */
	protected void sequence_Override(ISerializationContext context, uw.cs.watform.forml.forml.Override semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FormlPackage.Literals.OVERRIDE__TRANSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FormlPackage.Literals.OVERRIDE__TRANSITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOverrideAccess().getTransitionTransitionIDTerminalRuleCall_2_0_1(), semanticObject.eGet(FormlPackage.Literals.OVERRIDE__TRANSITION, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Predicate returns Predicate
	 *
	 * Constraint:
	 *     (((logicop='no' | logicop='lone' | logicop='one' | logicop='some' | logicop='all') var=Variable sexpr=setExpr)? quantPred=notPred)
	 */
	protected void sequence_Predicate(ISerializationContext context, Predicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Priority returns Priority
	 *
	 * Constraint:
	 *     translist=TransList
	 */
	protected void sequence_Priority(ISerializationContext context, Priority semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FormlPackage.Literals.PRIORITY__TRANSLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FormlPackage.Literals.PRIORITY__TRANSLIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPriorityAccess().getTranslistTransListParserRuleCall_1_0(), semanticObject.getTranslist());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RefMessage returns RefMessage
	 *
	 * Constraint:
	 *     refMsg=[Message|ID]
	 */
	protected void sequence_RefMessage(ISerializationContext context, RefMessage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FormlPackage.Literals.REF_MESSAGE__REF_MSG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FormlPackage.Literals.REF_MESSAGE__REF_MSG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRefMessageAccess().getRefMsgMessageIDTerminalRuleCall_1_0_1(), semanticObject.eGet(FormlPackage.Literals.REF_MESSAGE__REF_MSG, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeType returns ReferenceType
	 *     ReferenceType returns ReferenceType
	 *
	 * Constraint:
	 *     ref=[Concept|ID]
	 */
	protected void sequence_ReferenceType(ISerializationContext context, ReferenceType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FormlPackage.Literals.REFERENCE_TYPE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FormlPackage.Literals.REFERENCE_TYPE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceTypeAccess().getRefConceptIDTerminalRuleCall_0_1(), semanticObject.eGet(FormlPackage.Literals.REFERENCE_TYPE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RegionContext returns RegionContext
	 *
	 * Constraint:
	 *     (ref=[Region|QualifiedName] states+=State*)
	 */
	protected void sequence_RegionContext(ISerializationContext context, RegionContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Region returns Region
	 *
	 * Constraint:
	 *     (name=ID init=InitState? states+=State*)
	 */
	protected void sequence_Region(ISerializationContext context, Region semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Role returns Role
	 *
	 * Constraint:
	 *     (name=ID multiplicity=Multiplicity? type=[Roleable|ID])
	 */
	protected void sequence_Role(ISerializationContext context, Role semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprRef returns SPL
	 *     Concept returns SPL
	 *     SPL returns SPL
	 *
	 * Constraint:
	 *     (name=ID featureNodes+=FeatureNode* xors+=XORNode* ands+=AndNode* ors+=OrNode*)
	 */
	protected void sequence_SPL(ISerializationContext context, SPL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateContext returns StateContext
	 *
	 * Constraint:
	 *     (ref=[State|QualifiedName] regions+=Region*)
	 */
	protected void sequence_StateContext(ISerializationContext context, StateContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateMachineContext returns StateMachineContext
	 *
	 * Constraint:
	 *     (ref=[StateMachine|QualifiedName] state+=State*)
	 */
	protected void sequence_StateMachineContext(ISerializationContext context, StateMachineContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateMachine returns StateMachine
	 *
	 * Constraint:
	 *     (name=ID (regions+=Region | transitions+=Transition)*)
	 */
	protected void sequence_StateMachine(ISerializationContext context, StateMachine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     State returns State
	 *
	 * Constraint:
	 *     (name=ID regions+=Region*)
	 */
	protected void sequence_State(ISerializationContext context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeType returns StringType
	 *     StringType returns StringType
	 *
	 * Constraint:
	 *     {StringType}
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     System returns System
	 *
	 * Constraint:
	 *     (worldmodel=WorldModel | behaviourmodel=BehaviourModel)*
	 */
	protected void sequence_System(ISerializationContext context, uw.cs.watform.forml.forml.System semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TranFragment returns TranFragment
	 *
	 * Constraint:
	 *     (ref=[Transition|QualifiedName] trig=Trigger? fragType=Guard list=WCAList? fragList=WCAFragmentList?)
	 */
	protected void sequence_TranFragment(ISerializationContext context, TranFragment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransList returns TransList
	 *
	 * Constraint:
	 *     (transitions+=[Transition|ID] transitions+=[Transition|ID]*)
	 */
	protected void sequence_TransList(ISerializationContext context, TransList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Transition returns Transition
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         priority=Priority? 
	 *         src=[State|QualifiedName] 
	 *         dst=[State|QualifiedName] 
	 *         trig=Trigger? 
	 *         guard=Guard? 
	 *         list=WCAList?
	 *     )
	 */
	protected void sequence_Transition(ISerializationContext context, Transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Trigger returns Trigger
	 *
	 * Constraint:
	 *     (override=Override | wce=WCE)?
	 */
	protected void sequence_Trigger(ISerializationContext context, Trigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprRef returns UndefinedType
	 *     Concept returns UndefinedType
	 *     AttributeType returns UndefinedType
	 *     UndefinedType returns UndefinedType
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_UndefinedType(ISerializationContext context, UndefinedType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FormlPackage.Literals.CONCEPT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FormlPackage.Literals.CONCEPT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUndefinedTypeAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FormlPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FormlPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WCAFragmentList returns WCAFragmentList
	 *
	 * Constraint:
	 *     (frag+=WCAFragment frag+=WCAFragment*)
	 */
	protected void sequence_WCAFragmentList(ISerializationContext context, WCAFragmentList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WCAFragment returns WCAFragment
	 *
	 * Constraint:
	 *     (ref=[WCA|QualifiedName] fragType=Guard)
	 */
	protected void sequence_WCAFragment(ISerializationContext context, WCAFragment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FormlPackage.Literals.WCA_FRAGMENT__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FormlPackage.Literals.WCA_FRAGMENT__REF));
			if (transientValues.isValueTransient(semanticObject, FormlPackage.Literals.WCA_FRAGMENT__FRAG_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FormlPackage.Literals.WCA_FRAGMENT__FRAG_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWCAFragmentAccess().getRefWCAQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(FormlPackage.Literals.WCA_FRAGMENT__REF, false));
		feeder.accept(grammarAccess.getWCAFragmentAccess().getFragTypeGuardParserRuleCall_3_0(), semanticObject.getFragType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WCAList returns WCAList
	 *
	 * Constraint:
	 *     (actions+=WCA actions+=WCA*)?
	 */
	protected void sequence_WCAList(ISerializationContext context, WCAList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WCA returns WCA
	 *
	 * Constraint:
	 *     (name=ID action=Action?)
	 */
	protected void sequence_WCA(ISerializationContext context, WCA semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WCE returns WCE
	 *
	 * Constraint:
	 *     (addobj=[ExprRef|QualifiedName] | attr=[Attribute|QualifiedName] | remobj=[ExprRef|QualifiedName])
	 */
	protected void sequence_WCE(ISerializationContext context, WCE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WorldModel returns WorldModel
	 *
	 * Constraint:
	 *     (concepts+=Concept* constraints=Constraint?)
	 */
	protected void sequence_WorldModel(ISerializationContext context, WorldModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XORNode returns XORNode
	 *
	 * Constraint:
	 *     (featureNodes+=FeatureNode featureNodes+=FeatureNode+)
	 */
	protected void sequence_XORNode(ISerializationContext context, XORNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     andPred returns andPred
	 *
	 * Constraint:
	 *     (preds+=impPred preds+=impPred*)
	 */
	protected void sequence_andPred(ISerializationContext context, andPred semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     atomic returns atomic
	 *
	 * Constraint:
	 *     (none='none' | ref=[ExprRef|QualifiedName] | refs=[ExprRef|QualifiedName])
	 */
	protected void sequence_atomic(ISerializationContext context, atomic semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     basePred returns basePred
	 *
	 * Constraint:
	 *     (
	 *         ((logicop='no' | logicop='lone' | logicop='one' | logicop='some' | logicop='all') cardpred=setExpr) | 
	 *         (setlhs=predExpr (logicop='in' | logicop='=') setrhs=predExpr?) | 
	 *         (setlhs=predExpr (logicop='in' | logicop='=') boolrhs=boolExpr) | 
	 *         (
	 *             intlhs=intExpr 
	 *             (
	 *                 op='=' | 
	 *                 op='<>' | 
	 *                 op='>' | 
	 *                 op='<' | 
	 *                 op='>=' | 
	 *                 op='=>' | 
	 *                 op='<=' | 
	 *                 op='=<'
	 *             ) 
	 *             intrhs=intExpr?
	 *         ) | 
	 *         parenPred=Predicate
	 *     )
	 */
	protected void sequence_basePred(ISerializationContext context, basePred semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     boolExpr returns boolExpr
	 *
	 * Constraint:
	 *     (isTrue='true' | isFalse='false')
	 */
	protected void sequence_boolExpr(ISerializationContext context, boolExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     impPred returns impPred
	 *
	 * Constraint:
	 *     (preds+=orPred ((logicop+='implies' | logicop+='iff') preds+=orPred)*)
	 */
	protected void sequence_impPred(ISerializationContext context, impPred semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     intBase returns intBase
	 *
	 * Constraint:
	 *     (atom=atomic | num=INT)
	 */
	protected void sequence_intBase(ISerializationContext context, intBase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     intExpr returns intExpr
	 *
	 * Constraint:
	 *     (lhs=multExpr ((op+='+' | op+='-') rhs+=multExpr)*)
	 */
	protected void sequence_intExpr(ISerializationContext context, intExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     multExpr returns multExpr
	 *
	 * Constraint:
	 *     (lhs=intBase ((op+='*' | op+='/') rhs+=intBase)*)
	 */
	protected void sequence_multExpr(ISerializationContext context, multExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     notPred returns notPred
	 *
	 * Constraint:
	 *     (pred=Predicate | pred=andPred)
	 */
	protected void sequence_notPred(ISerializationContext context, notPred semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     orPred returns orPred
	 *
	 * Constraint:
	 *     (preds+=basePred preds+=basePred*)
	 */
	protected void sequence_orPred(ISerializationContext context, orPred semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     predExpr2 returns predExpr2
	 *
	 * Constraint:
	 *     (expr+=predExpr3 ((op+='-' | op+='+') expr+=predExpr3)*)
	 */
	protected void sequence_predExpr2(ISerializationContext context, predExpr2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     predExpr3 returns predExpr3
	 *
	 * Constraint:
	 *     base=setExprBase
	 */
	protected void sequence_predExpr3(ISerializationContext context, predExpr3 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FormlPackage.Literals.PRED_EXPR3__BASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FormlPackage.Literals.PRED_EXPR3__BASE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredExpr3Access().getBaseSetExprBaseParserRuleCall_0(), semanticObject.getBase());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     predExpr returns predExpr
	 *
	 * Constraint:
	 *     (expr+=predExpr2 expr+=predExpr2*)
	 */
	protected void sequence_predExpr(ISerializationContext context, predExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     setExpr2 returns setExpr2
	 *
	 * Constraint:
	 *     (expr+=setExpr3 ((op+='-' | op+='+') expr+=setExpr3)*)
	 */
	protected void sequence_setExpr2(ISerializationContext context, setExpr2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     setExpr3 returns setExpr3
	 *
	 * Constraint:
	 *     (paren=setExprBase | base=setExprBase)
	 */
	protected void sequence_setExpr3(ISerializationContext context, setExpr3 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     setExprBase returns setExprBase
	 *
	 * Constraint:
	 *     (atom=atomic | unspec=unspecified)
	 */
	protected void sequence_setExprBase(ISerializationContext context, setExprBase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     setExpr returns setExpr
	 *
	 * Constraint:
	 *     (expr+=setExpr2 expr+=setExpr2*)
	 */
	protected void sequence_setExpr(ISerializationContext context, setExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unspecified returns unspecified
	 *
	 * Constraint:
	 *     ref=[ExprRef|ID]
	 */
	protected void sequence_unspecified(ISerializationContext context, unspecified semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FormlPackage.Literals.UNSPECIFIED__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FormlPackage.Literals.UNSPECIFIED__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnspecifiedAccess().getRefExprRefIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FormlPackage.Literals.UNSPECIFIED__REF, false));
		feeder.finish();
	}
	
	
}
