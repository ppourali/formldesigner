/*
 * generated by Xtext
 */
package uw.cs.watform.forml.validation

import org.eclipse.xtext.validation.Check
import uw.cs.watform.forml.forml.WorldModel
import uw.cs.watform.forml.forml.FormlPackage
import uw.cs.watform.forml.forml.Constraint
import uw.cs.watform.forml.forml.FormlFactory
import org.eclipse.emf.ecore.EcoreFactory
import uw.cs.watform.forml.forml.Guard
import org.eclipse.emf.ecore.util.EcoreUtil.AbstractFilteredSettingsIterator
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.EcoreUtil2
import uw.cs.watform.forml.forml.atomic
import java.util.List
import uw.cs.watform.forml.forml.ExprRef
import uw.cs.watform.forml.forml.Message
import uw.cs.watform.forml.forml.Input
import uw.cs.watform.forml.forml.AttributeType
import uw.cs.watform.forml.forml.Output
import uw.cs.watform.forml.forml.Attribute
import uw.cs.watform.forml.forml.Function
import uw.cs.watform.forml.forml.IntType
import uw.cs.watform.forml.forml.BoolType
import uw.cs.watform.forml.forml.Enumeration
import uw.cs.watform.forml.forml.ReferenceType
import uw.cs.watform.forml.forml.impPred

//import org.eclipse.xtext.validation.Check
/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class FormlValidator extends AbstractFormlValidator {

	@Check
	def checkConstraintsElementExist(Guard g) {

		var List<impPred> imppreds = EcoreUtil2.getAllContentsOfType(g, impPred);
		for (ip : imppreds) {
			var atomics = EcoreUtil2.getAllContentsOfType(ip, typeof(atomic));
			if (!isTypeSound(atomics))
				warning('The types are not sound by type.', FormlPackage.Literals.GUARD__PREDICATE);
		}
	}

	def boolean isTypeSound(List<atomic> atomics) {

		if (atomics.size < 2) {
			return true;
		}
		if (atomics.size == 2) {
			var atomic atom1 = atomics.get(0);
			var atomic atom2 = atomics.get(1);

			var ExprRef ref1 = atom1.ref;
			var ExprRef ref2 = atom2.ref;

			var AttributeType type1;
			var AttributeType type2;

			type1 = getTypeOf(ref1);
			type2 = getTypeOf(ref2);

			if (type1 !== null && type2 !== null) {
				if (type1 instanceof IntType && type2 instanceof IntType) {
					return true;
				}
				if (type1 instanceof BoolType && type2 instanceof BoolType) {
					return true;
				}
				if (type1 instanceof Enumeration && type2 instanceof Enumeration) {
					if (Enumeration.cast(type1).name.equalsIgnoreCase(Enumeration.cast(type2).name))
						return true;
				}
				if (type1 instanceof ReferenceType && type2 instanceof ReferenceType) {
					if (ReferenceType.cast(type1).ref.name.equalsIgnoreCase(ReferenceType.cast(type2).ref.name))
						return true;
				}

			} else if (type1 === null || type2 === null) {
				return true;
			}

		}
		return false;
	}

	def AttributeType getTypeOf(ExprRef ref) {
		if (ref instanceof Input) {
			return Input.cast(ref).type;
		} else if (ref instanceof Output) {
			return Output.cast(ref).type;
		} else if (ref instanceof Attribute) {
			return Attribute.cast(ref).type;
		} else if (ref instanceof Function) {
			return Function.cast(ref).type;
		}
	}

//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
//	@Check
//	def checkConstraintsElementExist(WorldModel wm) {
//
//		if (wm.constraints == null) {
//
//			wm.constraints = FormlFactory::eINSTANCE.createConstraint
//
//			warning('World Model Must have at least one Constraint Element(even if empty)',
//				FormlPackage.Literals.WORLD_MODEL__CONSTRAINTS);
//
//		// FormlFactory::eINSTANCE.createConstraint;
//		}
//	}
}
